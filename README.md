# CS7319-Final-Project-Group-11-Ping-he_Pengfang-chen
# compilation & implementation platform with the version
Apache NetBeans 19 
URL: https://netbeans.apache.org/front/main/download/nb19/
JDK 17
URL: https://www.oracle.com/java/technologies/downloads/#jdk21-mac
flatlaf-3.2.5.jar
URL:https://search.maven.org/artifact/com.formdev/flatlaf/3.2.5/jar?eh=
# how to compile code and how to execute system
run EventDriven.java file in Apache NetBeans 19 to execute the event-based architecture application 
run Layered.java file to in Apache NetBeans 19 execute the layered architecture application 
#	Elaborate in detail on the difference between the architecture designs for both candidate architecture styles and the rationales for your final selection.
Difference between the architecture designs:
For layered architecture:
(1)The ExpenseIncomeTrackerUI class is responsible for building and managing the user interface.
(2)The Transaction class represents a transaction, containing the date, description, amount, and transaction type.
(3)The TransactionRepository class is responsible for managing transaction records, including adding new transactions and retrieving all transaction records.
(4)The TransactionService class provides a service layer for managing transactions. It depends on TransactionRepository to store and retrieve transaction data.
For event-based architecture:
It has four components including event source, which generates events when clicked; event listener, which listens for events and responds by invoking the actionPerformed method when the event occurs；event handler, responsible for responding to the event generated by the event source；and UI elements, which are part of the user interface and can trigger or respond to events. Its connector is data flow, through which expense and income records and related information flow between various components.

Layered Architecture:
Pros:
Scalability: The expense-income tracker app may need to support growing data volumes and user bases. A layered architecture makes it easier to add new features.
Security: Our application involves sensitive financial data. A layered architecture allows the implementation of security measures at different layers, such as data access control at the data access layer. 
Maintainability: Our application often requires continuous updates, such as adding new account types, or payment methods. A layered architecture allows for modifications and extensions of specific functionalities without impacting other layers.

Cons:
Complexity: Many layers can lead to increased overhead in terms of development time and resources.
Performance Overhead: Our app often deals with large volumes of financial data, which can lead to performance issues when data needs to be serialized and deserialized as it passes between different layers. This overhead can impact the real-time processing and responsiveness of the application。

Event based architecture :
Pros:
Responsiveness: The software can respond to user actions and external events in real-time. For our expense-income tracker app, this means that users can instantly see updates to their financial records as they enter expenses or income.
Loose Coupling: Event-based architecture simplifies maintenance and makes it easier to extend the application. For our app, this means that we can add new features, such as expense categories or reporting tools, without disrupting the existing functionality.
Parallel Execution:Events can be processed in parallel, enabling multitasking and efficient resource utilization. In our app, this can be particularly useful for performing calculations or updates on multiple financial records concurrently.

Cons:
Complexity:Our application may become complex due to the need to manage multiple financial events. The handling of various financial transactions, categories, and user interactions can lead to intricate event management, potentially making the codebase harder to understand and maintain.
Potential for Race Conditions: In multithreaded applications, event-driven systems can introduce race conditions and concurrency issues. Simultaneous updates to financial records or calculations could result in unexpected and erroneous data changes.
Difficulty in Tracking Flow: Tracking the flow of control in an event-based expense and income tracker application can be challenging. With financial events dispersed across multiple event handlers, it may become more difficult to follow the sequence of financial transactions and calculations in the code, potentially impacting code readability and debugging.

Rationales for final selection. 
Informed by the expectations and requirements of our stakeholders for an expense income tracking application, with a primary emphasis on analyzing non-functional properties, we ultimately opted for event-based architecture.

First and foremost, our application needs to provide immediate updates and customization for unique financial situations, while remaining user-friendly and accommodating multi-user collaboration. The key attributes of event-based architecture, including responsiveness, user-friendliness, and parallel execution, align perfectly with these user-centric demands.

Additionally, for our development team, it's crucial that the application maintains optimal performance as the user base expands. This is where the concept of loose coupling, as previously discussed, justified our choice of event-based architecture.

Lastly, for future testing and management, the ability to efficiently test independent modules is essential. Event-based architecture perfectly meets this requirement.

In conclusion, our decision to employ event-based architecture was driven by the need to fulfill stakeholder expectations, user demands, development scalability, and efficient testing and management.
